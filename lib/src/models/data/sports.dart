import "dart:async";

import "package:flutter/foundation.dart";

import "package:ramaz/data.dart";
import "package:ramaz/services.dart";

/// Different ways to sort the sports calendar.
enum SortOption {
	/// Sorts the sports games chronologically.
	/// 
	/// Uses [SportsGame.date].
	chronological, 

	/// Sorts the sports game by sport. 
	/// 
	/// Uses [SportsGame.sport].
	sport
}

/// A view model for the sports page. 
/// 
/// This model is in charge of reading the games from [Reader.sportsData] and
/// sorting them into recent and upcoming, as well as further sorting by sport,
/// if the user chooses. 
// ignore: prefer_mixin
class Sports with ChangeNotifier {
	/// Sorts games by their sport.
	/// 
	/// Produces a map where the keys are [SportsGame.sport] and the values are
	/// lists of all the games with that sport. 
	Map<Sport, List<int>> sortBySport(List<int> gamesList) {
		final Map<Sport, List<int>> result = {};
		for (final int index in gamesList) {
			final SportsGame game = games [index];
			if (!result.keys.contains(game.sport)) {
				result [game.sport] = [index];
			} else {
				result [game.sport].add(index);
			}
		}
		// Sort those list chronologically.
		for (final List<int> gamesList in result.values) {
			gamesList.sort(sortByDate);
		}
		return result;
	}

	static const _minute = Duration(minutes: 1);

	static DateTime _now = DateTime.now();	

	/// Provides access to the file system.
	/// 
	/// A list of sports games is available in [Reader.sportsData].
	final Reader reader;

	/// A function to refresh the list of sports games. 
	final Future<void> Function() refresh;

	/// A timer to refresh the games lists. 
	/// 
	/// This is used to reset the day to the current day. 
	/// It's useful for midnight, when an upcoming game can become a recent game.  
	Timer timer;

	/// A list of all the games taking place.
	List<SportsGame> games;

	/// Games that happened in the past.
	List<int> recents;

	/// Games that are yet to happen.
	List<int> upcoming;

	/// A list of games that are being played today.
	/// 
	/// This will be shown on the home screen. 
	List<int> todayGames; 

	/// Recent games sorted by sport.
	/// 
	/// Generated by calling [sortBySport] with [recents]. 
	Map<Sport, List<int>> recentBySport;

	/// Upcoming games sorted by sport. 
	/// 
	/// Generated by calling [sortBySport] with [upcoming].
	Map<Sport, List<int>> upcomingBySport;

	SortOption _sortOption = SortOption.chronological;

	bool _loading = false;

	/// If the user is an admin. 
	/// 
	/// This will allow widgets to give the user options to change some entries.
	bool isAdmin = false;

	/// Creates a sports view model.
	Sports(this.reader, this.refresh) {
		timer = Timer.periodic(_minute, (_) => setup);
		Auth.isSportsAdmin.then(
			(bool value) {
				isAdmin = value;
				notifyListeners();
		});
		setup(fromDevice: true);
	}

	@override
	void dispose() {
		timer.cancel();
		super.dispose();
	}

	/// Sorts games by date using [SportsGame.dateTime].
	int sortByDate(int a, int b) => 
		games [a].dateTime.compareTo(games [b].dateTime);

	/// The mode selected for sorting [games]. 
	SortOption get sortOption => _sortOption;
	set sortOption(SortOption value) {
		_sortOption = value;
		sort();
		notifyListeners();
	}

	/// Loads the games from [reader] and sorts them.
	void setup({bool fromDevice = false}) {
		if (fromDevice) {
			games = SportsGame.fromList(reader.sportsData);
		}
		sortByRecentAndUpcoming();
		_now = DateTime.now();
		todayGames = getTodayGames();
		sort();
		notifyListeners();
	}

	/// Returns games from [games] if the game is today.
	/// 
	/// This is used to populate [todayGames].
	List<int> getTodayGames() => [
		for (final MapEntry<int, SportsGame> entry in games.asMap().entries) 
			if (
				entry.value.date.year == _now.year && 
				entry.value.date.month == _now.month && 
				entry.value.date.day == _now.day
			) entry.key
	];

	/// Sorts the games by past and future. 
	void sortByRecentAndUpcoming() {
		recents = [];
		upcoming = [];
		final DateTime now = DateTime.now();
		for (final MapEntry<int, SportsGame> entry in games.asMap().entries) {
			(entry.value.dateTime.isAfter(now) ? upcoming : recents).add(entry.key);
		}
		recents?.sort(sortByDate);
		upcoming?.sort(sortByDate);
	}

	/// Sorts the games based on [sortOption]. 
	void sort() {
		switch (sortOption) {
			case SortOption.chronological: break;
			case SortOption.sport:
				recentBySport = sortBySport(recents);
				upcomingBySport = sortBySport(upcoming);
		}
	}

	/// Adds a game to the database. 
	Future<void> addGame(SportsGame game) async {
		if (game == null) {
			return;
		} else {
			loading = true;
			games.add(game);
			return saveGames();  // returns a future
		}
	}

	/// Replaces a game with another and saves it to the database.
	/// 
	/// Since [SportsGame]s are immutable, they cannot be changed in place. 
	/// Instead, they are removed and replaced. 
	Future<void> replace(int index, SportsGame newGame) async {
		if (newGame == null) {
			return;
		}
		loading = true;
		games [index] = newGame;
		return saveGames();
	}

	/// Deletes a game from the database.
	Future<void> delete(int index) {
		loading = true;
		games.removeAt(index);
		return saveGames();
	}

	/// Saves the games to the database. 
	/// 
	/// Also cancels the loading indicator.
	Future<void> saveGames() async {
		await Firestore.saveGames(SportsGame.getJsonList(games));
		loading = false;
	}

	/// Whether the page is loading. 
	bool get loading => _loading;
	set loading(bool value) {
		_loading = value;
		notifyListeners();
	}
}
